package metrics

import (
	"eagle-server/shared/management/core"
	"fmt"
	"strings"

	"github.com/kataras/golog"
)

var metricQueryMap map[string]string = map[string]string{
	"sessions":                SESSIONS_QUERY_TEMPLATE,
	"avg_diaas":               AVARAGE_DIAAS_QUERY_TEMPLATE,
	"avg_diaas_non_compliant": AVARAGE_DIAAS_QUERY_NON_COMPLIANT_TEMPLATE,
	"issues":                  ISSUES_QUERY_TEMPLATE,
	"approved_by_grace":       APPROVED_BY_GRACE,
	"resolved_issues":         RESOLVED_ISSUES,
}

type Service struct {
	context *core.AppContext
}

func New(appContext *core.AppContext) *Service {
	return &Service{
		context: appContext,
	}
}

func (s *Service) GetMetric(tenant int32, metricName string, seconds int, minDate int64, maxDate int64, metricQuery string) (*MetricEntity, error) {
	conn := s.context.Clickhouse.Conn

	var result []TimeSeriesEntity

	aggregationTime := seconds * 1000

	err := conn.Select(&result, fmt.Sprintf(metricQuery, tenant, aggregationTime, minDate, maxDate))

	if err != nil {
		return nil, err
	}

	metricEntity := MetricEntity{
		Name:       metricName,
		TimeSeries: result,
	}

	return &metricEntity, nil
}

// if metricQuery, ok := metricQueryMap[metricName]; ok {
// 	err := conn.Select(&result, fmt.Sprintf(metricQuery, tenant, aggregationTime, minDate, maxDate))
// 	if err != nil {
// 		return nil, err
// 	}
// } else {
// 	return nil, fmt.Errorf("metric name not found")
// }

//TODO: Change []TimeSeriesEntity TO ==>  []*TimeSeriesEntity !!!
// func getTimeSeries() ([]TimeSeriesEntity, error) {
// 	var timeSeries []TimeSeriesEntity

// 	err := conn.Select(&timeSeries, fmt.Sprintf(metricQuery, tenant, aggregationTime, minDate, maxDate))

// }

func (s *Service) getMetricModel() ([]*CreateMetricModel, error) {
	var metricsModel []*CreateMetricModel

	err := s.context.Db.Select(&metricsModel, `SELECT m.metric_id, m.metric_description, m.sub_title, m.title FROM metrics m`)

	return metricsModel, err
}

func (s *Service) CreateNewMetric(cmm *CreateMetricModel) error { // TODO: (*CreateMetricModel, error)

	queryResult, err := s.context.Db.Exec(
		`INSERT INTO metrics (metric_id, metric_description, query, sub_title, title ) VALUES ($1, $2, $3, $4, $5)`,
		cmm.Name, cmm.Description, cmm.Query, cmm.SubTitle, cmm.Title)

	golog.Info(queryResult)
	golog.Info(err)
	return err
	// TODO: Split the CONSTRAINTerror:  1. NOt found 2.Postgress connection

}

func findMetricModel(metricName string, metricsModel []*CreateMetricModel) *CreateMetricModel {
	if len(metricsModel) == 0 {
		return nil
	}

	for i := 0; i < len(metricsModel); i++ {
		if metricsModel[i].Name == metricName {
			return metricsModel[i]
		}
	}

	return nil
}

// func (s *Service) GetMetrics(tenantId int32, metrics []string, seconds int, minDate int64, maxDate int64) MetricsEntity {
func (s *Service) GetMetrics(tenantId int32, queryModel *GetMetricsRequestModel) []*MetricsEntity {
	metricsEntities := make([]*MetricsEntity, 0, len(queryModel.Metrics))
	var metricsModel []*CreateMetricModel
	var metricModel *CreateMetricModel
	err := s.context.Db.Select(&metricsModel, `SELECT m.query, m.metric_id, m.metric_description , m.title, m.sub_title FROM metrics m WHERE m.metric_id IN ($1) `, queryModel.Metrics)

	if err != nil {
		golog.Error("no metrics found, reason: %s , trying to get: %s ", err, strings.Join(queryModel.Metrics, " , "))
		return metricsEntities
	}

	for i, metricName := range queryModel.Metrics {
		metricModel = findMetricModel(metricName, metricsModel) // TODO if metricQuery == nil
		metricEntity, err := s.GetMetric(tenantId, metricName, queryModel.AggregateSeconds, queryModel.MinDate, queryModel.MaxDate, *metricModel.Query)
		if err != nil {
			golog.Errorf("Error getting metric %s (%d/%d): %s", metricName, i, len(queryModel.Metrics), err)
			continue // Skipping to Next Metric that can be found
		}

		metricEntity.
			metricsEntityResponse.Metrics = append(metricsEntityResponse.Metrics, *metricEntity)

	}

}
