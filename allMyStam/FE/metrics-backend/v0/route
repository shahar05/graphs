package metrics

import (
	"eagle-server/management/search"
	"eagle-server/shared/general"
	"eagle-server/shared/management/core"

	"github.com/kataras/golog"
	"github.com/kataras/iris/v12"
)

type CreateMetricModel struct {
	MetricId    string              `db:"metric_id" json:"name"`
	Title       *string             `db:"title" json:"title"`
	Description *string             `db:"metric_description" json:"description"`
	Query       *[]MetricQueryModel `json:"query, omitempty"`
}

type MetricQueryModel struct {
	QueryId     *string `db:"query_id" json:"query_id,omitempty"`
	Query       *string `db:"query" json:"query"`
	Title       *string `db:"title" json:"title"`
	Description *string `db:"description" json:"description"`
}

type GetMetricsRequestModel struct {
	Metrics          []string `json:"metrics"`
	MinDate          int64    `json:"minDate"`
	MaxDate          int64    `json:"maxDate"`
	AggregateSeconds int      `json:"aggregateSeconds"`
}

type MetricQueryRelation struct {
	QueryId  *string `db:"query_id"`
	MetricId string  `db:"metric_id"`
}

func RegisterMetricsRouter(server *iris.Application, context *core.AppContext) {
	svc := New(context)

	a := server.Party("/m/metrics") // Should I add Here /m???? I think there is a global const or something...
	{
		a.Post("/", func(ctx iris.Context) {

			tenantID := general.GetTenantID(ctx)

			queryModel := &GetMetricsRequestModel{}

			if !core.ReadAndValidate(ctx, queryModel) {
				golog.Errorf("incorrect query model")
				return
			}

			golog.Debugf("handling api call /m/metrics %+v", queryModel)

			met := svc.GetMetrics(tenantID, queryModel) // TODO: Error handling: check met Object if nill && GetMetrics should emit error if needed

			res := search.QueryResponseModel{
				Total: len(met.Metrics),
				Items: met,
			}

			golog.Debugf("result for /m/metrics with %+v is %+v", queryModel, res)

			ctx.JSON(res)
		})

		a.Get("/", func(ctx iris.Context) { // TODO: Change to ==> /MetaData route ==> /m/metrics/metadata
			metricsModel, err := svc.getMetricModel()

			if err != nil {
				golog.Error(err)
				return
			}

			ctx.JSON(metricsModel)
		})

		a.Get("/names", func(ctx iris.Context) {
			metricsNames := make([]string, 0, len(metricQueryMap))

			for metricName := range metricQueryMap {
				metricsNames = append(metricsNames, metricName)
			}

			ctx.JSON(metricsNames)
		})

		a.Post("/create", func(ctx iris.Context) {
			createMetricModel := &CreateMetricModel{}

			if !core.ReadAndValidate(ctx, createMetricModel) {
				return
			}

			err := svc.CreateNewMetric(createMetricModel)

			ctx.JSON(err)
		})

	}
}
